#!/bin/bash

OPTIONS=""
USERNAME=""
VALID="s|u|n|t|h|a"

# A function to ensure that the passed options are valid
# Recieves IN ORDER: options entered, valid options separated by a vertical bar
function parse_options () {
	# If options do not start with a dash, exit
	if [ ! ${1:0:1} = '-' ]
	then
		printf "ERROR: Options must start with a dash (-).\n"
		exit 1
	fi

	# If the a option is used, but not the only option, exit
	if [[ $1 =~ "a" ]] && [ ${#1} -gt 2 ]
	then
		printf "ERROR: Cannot have option \"a\" with other options.\n"
		exit 2
	fi

	# For every character of the entered options
	# Starting at 1, because the character 0 should be a dash, not a letter
	i="1"
	j="2"
	while [ $i -lt ${#1} ]
	do
		# Get the ith character
		curr=${1:i:1}

		# If the character is not in the valid options, exit
		if [[ ! $curr =~ $2 ]]
		then
			printf "ERROR: Invalid option: "$curr".\n"
			exit 3
		fi

		# If the character repeats later, exit
		while [ $j -lt ${#1} ]
                do
                        if [ $curr = ${1:j:1} ]
                        then
                                printf "ERROR: Repeat option: "$curr".\n"
                                exit 4
                        fi
                        j=$[$j+1]
                done

		# Update the positions
		i=$[$i+1]
		j=$[$i+1]
	done
}


# Parse the arguments passed to start this script
function parse_arguments () {
	if [ $# -eq 1 ] # If there is a one argument, then it is the username
	then
		OPTIONS="-a"
		USERNAME=$1
	elif [ $# -eq 2 ] # If there are two arguments, then it goes options then username
	then
		OPTIONS=$1
		USERNAME=$2
		parse_options $OPTIONS $VALID
	else # If there are zero or more arguments, then something is wrong
		printf "Unexpected number of arguements. Follow the pattern \"unfo [options] [username]\"\n"
		exit 5
	fi
}

# Print the username field
function username () {
	printf "%-23s" "Username:"
	echo $USERNAME
}

# Print the fullname field
function fullname () {
	printf "%-23s" "Full Name:"
	echo $(grep "$USERNAME" /etc/passwd | cut -d ':' -f 5 | sed 's/...$//')
}

# Print the home directory field
function home_dir () {
	printf "%-23s" "Home Directory:"
	echo $(grep "$USERNAME" /etc/passwd | cut -d ':' -f 6)
}

# Print the log in time field
function login_time () {
	printf "%-23s" "Time of last login:"
	echo $(last | tac | grep "$USERNAME" | tail --lines=1 | tr -s ' ' | cut -d ' ' -f 4-7)
}

# Print the status field
function status () {
	STATUS=$(last | tac | grep "$USERNAME" | tail --lines=1 | awk 'NR==1{print $NF}')

	printf "%-23s" "Status:"
	if [ -z $STATUS ]
	then
		echo ""
	elif [ $STATUS = "in" ]
	then
		echo "Logged in"
	else
		echo "Logged out"
	fi
}

function main () {
	# Username
	if [[ $OPTIONS =~ "u" ]] || [[ $OPTIONS =~ "a" ]]; then username; fi

	# Full Name
	if [[ $OPTIONS =~ "n" ]] || [[ $OPTIONS =~ "a" ]]; then fullname; fi

	# Home Directory
	if [[ $OPTIONS =~ "h" ]] || [[ $OPTIONS =~ "a" ]]; then home_dir; fi

	# Time of last login
	if [[ $OPTIONS =~ "t" ]] || [[ $OPTIONS =~ "a" ]]; then login_time; fi

	# If the user is currently logged in
	if [[ $OPTIONS =~ "s" ]] || [[ $OPTIONS =~ "a" ]]; then status; fi
}

parse_arguments $1 $2 $3
main
